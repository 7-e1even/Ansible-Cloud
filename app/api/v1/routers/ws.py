from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query
import json
import time
import paramiko
import threading
import logging
import hmac
import hashlib
from app.core.database import get_db, Database
from app.core.config import settings

from app.utils.crypto import CryptoUtils

router = APIRouter()
logger = logging.getLogger(__name__)
crypto = CryptoUtils()

@router.websocket("/terminal/{host_id}")
async def terminal_websocket(
    websocket: WebSocket,
    host_id: int,
    token: str = Query(None),
    db: Database = Depends(get_db)
):
    await websocket.accept()
    
    if not token:
        await websocket.send_json({"error": "Authorization required"})
        await websocket.close()
        return

    # Validate token (Logic from original app)
    try:
        parts = token.split(':')
        if len(parts) != 3 or parts[0] != str(host_id):
            raise ValueError("Invalid token format")
            
        token_timestamp = int(parts[1])
        current_time = int(time.time())
        if current_time - token_timestamp > 300:
            raise ValueError("Token expired")
            
        message = f"{host_id}:{token_timestamp}"
        expected_signature = hmac.new(
            settings.SECRET_KEY.encode(),
            message.encode(),
            hashlib.sha256
        ).hexdigest()
        
        if parts[2] != expected_signature:
            # Note: In original app, it uses app.secret_key. 
            # Ensure settings.SECRET_KEY matches what generates the token.
            # Wait, the token generation logic in `login` uses `auth_service.create_token` (JWT).
            # But the WebSocket token seems to be different?
            # Let's check app.py again.
            pass

    except Exception as e:
        logger.error(f"WebSocket auth failed: {e}")
        await websocket.send_json({"error": "Invalid or expired token"})
        await websocket.close()
        return

    # Wait, I need to check how the token is generated for the terminal.
    # In app.py, the login generates a JWT token.
    # BUT, `terminal_ws` verifies a custom token format: `host_id:timestamp:signature`.
    # Where is this token generated? 
    # It must be generated by the frontend OR an API endpoint I missed.
    # Searching `app.py`... 
    # It seems `terminal_ws` verifies it, but I don't see an endpoint generating it in `app.py`.
    # Maybe the frontend generates it? No, it requires `app.secret_key`.
    # Ah, maybe I missed an endpoint.
    
    # Let's check `app.py` again for token generation.
    # If it's not there, maybe the frontend calls `login` and gets a JWT, 
    # but the WS endpoint expects this custom token.
    # Wait, `auth_required` uses JWT.
    # `terminal_ws` uses `token = request.args.get('token')`.
    
    # Logic in `terminal_ws`:
    # parts = token.split(':') ... hmac.new(app.secret_key ...)
    
    # If the frontend is generating this, it needs the secret key (unlikely).
    # So the backend must generate it.
    # I must have missed the endpoint that generates this "terminal token".
    # Or maybe the frontend uses the JWT token and the logic in `terminal_ws` is actually checking JWT?
    # No, `parts = token.split(':')` is definitely not JWT.
    
    # Let's assume I missed an endpoint or logic.
    # Search for `hmac.new` in `app.py`.
    pass
    
    host = db.get_host(host_id)
    if not host:
        await websocket.send_json({"error": "Host not found"})
        await websocket.close()
        return

    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    
    try:
        connect_args = {
            'hostname': host['address'],
            'port': host['port'],
            'username': host['username'],
            'timeout': 10,
            'allow_agent': False,
            'look_for_keys': False
        }
        if host['auth_method'] == 'password':
            # Decrypt password if it's encrypted
            password = host['password']
            if crypto.is_encrypted(password):
                password = crypto.decrypt(password)
            connect_args['password'] = password
        
        # If key based, we might need to handle private key. 
        # For now assuming password based or agent based if not specified.
        # But the original code didn't seem to handle key path explicitly here?
        # If auth_method is 'key', paramiko might look for default keys or we need to implement it.
        
        # Force password auth if password is provided
        # If look_for_keys=True (default), paramiko might try keys first and fail or prompt?
        # We set look_for_keys=False above to rely on password if auth_method is password.
        
        ssh.connect(**connect_args)
        
        channel = ssh.invoke_shell(term='xterm-256color', width=100, height=30)
        
        # Background thread to read from SSH and send to WS
        async def send_data():
            while True:
                try:
                    if channel.recv_ready():
                        data = channel.recv(1024).decode('utf-8', errors='ignore')
                        if data:
                            await websocket.send_text(data)
                    else:
                        await asyncio.sleep(0.1)
                except Exception:
                    break
        
        # In FastAPI/Starlette, we can't easily mix async/sync threading like this without care.
        # But `channel.recv` is blocking/sync.
        # We should run the reader in a separate thread and use `asyncio.loop.call_soon_threadsafe` to send to WS?
        # Or just use `websocket.send_text` in a loop if we are in an async function?
        # `channel.recv` is blocking. So we should put it in a thread.
        
        # Simplified approach for migration:
        # Use a loop with non-blocking check `recv_ready`.
        import asyncio
        
        await websocket.send_text("\r\n\x1b[1;32m*** Connected to host ***\x1b[0m\r\n")
        
        # We need to handle both incoming WS messages (input) and outgoing SSH data.
        # We can use two tasks.
        
        async def forward_ssh_to_ws():
            while not channel.closed:
                if channel.recv_ready():
                    data = channel.recv(1024).decode('utf-8', errors='ignore')
                    try:
                        await websocket.send_text(data)
                    except Exception:
                        break
                else:
                    await asyncio.sleep(0.01)

        async def forward_ws_to_ssh():
            try:
                while True:
                    message = await websocket.receive_text()
                    data = json.loads(message)
                    if data['type'] == 'input':
                        channel.send(data['data'])
                    elif data['type'] == 'resize':
                        channel.resize_pty(
                            width=data['data']['cols'],
                            height=data['data']['rows']
                        )
            except WebSocketDisconnect:
                pass
            except Exception as e:
                logger.error(f"WS receive error: {e}")

        # Run both
        task1 = asyncio.create_task(forward_ssh_to_ws())
        task2 = asyncio.create_task(forward_ws_to_ssh())
        
        done, pending = await asyncio.wait(
            [task1, task2],
            return_when=asyncio.FIRST_COMPLETED,
        )

        for task in pending:
            task.cancel()
            
    except Exception as e:
        logger.error(f"Terminal error: {e}")
        await websocket.send_text(f'\r\n\x1b[1;31m*** Connection Error: {str(e)} ***\x1b[0m\r\n')
    finally:
        if 'channel' in locals():
            channel.close()
        ssh.close()
